package com.attunedlabs.leap.eventtracker.initializer;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.sql.DataSource;

import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.datasource.DataSourceUtils;

import com.attunedlabs.core.datagrid.DataGridService;
import com.attunedlabs.eventframework.config.EventFrameworkConfigurationException;
import com.attunedlabs.eventframework.config.IEventFrameworkConfigService;
import com.attunedlabs.eventframework.config.impl.EventFrameworkConfigService;
import com.attunedlabs.eventframework.dispatchchannel.exception.MessageDispatchingException;
import com.attunedlabs.eventframework.dispatcher.transformer.LeapEventTransformationException;
import com.attunedlabs.eventframework.event.ILeapEventService;
import com.attunedlabs.eventframework.event.InvalidEventException;
import com.attunedlabs.eventframework.event.LeapEvent;
import com.attunedlabs.eventframework.event.LeapEventService;
import com.attunedlabs.eventframework.eventtracker.EventDispatcherTracker;
import com.attunedlabs.eventframework.eventtracker.IEventDispatcherTrackerService;
import com.attunedlabs.eventframework.eventtracker.impl.EventDispatcherTrackerException;
import com.attunedlabs.eventframework.eventtracker.impl.EventDispatcherTrackerImpl;
import com.attunedlabs.eventframework.eventtracker.impl.EventTrackerTableConstants;
import com.attunedlabs.eventframework.eventtracker.util.EventTrackerUtil;
import com.attunedlabs.eventframework.retrypolicy.service.EventFrameworkRetryPolicyService;
import com.attunedlabs.leap.LeapHeader;
import com.attunedlabs.leap.LeapHeaderConstant;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;

/**
 * <code>RetryFailedEventTask</code> will retry the events that are marked as
 * FAILED or RETRY-FAILED or events that are IN_PROCESS for long time(assuming
 * some internal issue while dispatching).
 * 
 * @author Reactiveworks42
 *
 */
public class RetryFailedEventTask {

	final Logger logger = LoggerFactory.getLogger(RetryFailedEventTask.class);
	IEventFrameworkConfigService evtConfigService = new EventFrameworkConfigService();
	IEventDispatcherTrackerService eventDispatcherTrackerService = new EventDispatcherTrackerImpl();

	public void performTask(Exchange exchange) throws EventDispatcherTrackerException {
		logger.debug("inside performTask... to retry failed events ");
		IEventDispatcherTrackerService eventDispatcherTrackerService = new EventDispatcherTrackerImpl();

		logger.debug("RETRY_Event Job started at time" + new Date(System.currentTimeMillis()));
		// creating datasource in leapHeader and setting datasource in
		// resoureHolder.
		LeapHeader leapHeader = new LeapHeader();
		Map<Object, Object> resourceHolder = new HashMap<>();
		String dbRefName = EventTrackerTableConstants.Leap_DATASOURCE;
		logger.debug("Logging DbReferenceName: " + dbRefName);
		CamelContext camelContext = exchange.getContext();
		DataSource dataSourcegetting = (DataSource) camelContext.getRegistry().lookupByName(dbRefName);
		logger.debug("dataSourcegetting object: " + dataSourcegetting);
		resourceHolder.put(dataSourcegetting, DataSourceUtils.getConnection(dataSourcegetting));
		leapHeader.setResourceHolder(resourceHolder);

		// setting leap header in exchange generated by quartz.
		exchange.getIn().setHeader(LeapHeaderConstant.LEAP_HEADER_KEY, leapHeader);

		// check for new events from long time and re-publish them.
		List<EventDispatcherTracker> newLongTimeEvents = eventDispatcherTrackerService
				.getAllTrackRecordsIntitializedForLongTime(exchange);

		// check for in_process events for long time and re-publish them.
		List<EventDispatcherTracker> inProgressEvents = eventDispatcherTrackerService
				.getAllTrackRecordsInProcessForLongTimeArrangedByRetry(exchange,
						EventTrackerTableConstants.STATUS_IN_PROCESS);

		// check for retry_inprocess events for long time and re-publish them.
		List<EventDispatcherTracker> retryInProgressEvents = eventDispatcherTrackerService
				.getAllTrackRecordsInProcessForLongTimeArrangedByRetry(exchange,
						EventTrackerTableConstants.STATUS_RETRY_IN_PROCESS);

		// check for failed events and re-publish them.
		List<EventDispatcherTracker> failedEvents = eventDispatcherTrackerService
				.getAllFailedEventRecordsArrangedByFailureTimeAndRetryCount(exchange);

		// check for retry-failed events and re-publish them.
		List<EventDispatcherTracker> retryFailedEvents = eventDispatcherTrackerService
				.getAllRetryFailedEventRecordsArrangedByFailureTimeAndRetryCount(exchange);

		logger.debug("new event list for long time... " + newLongTimeEvents);
		logger.debug("inProgress event list ... " + inProgressEvents);
		logger.debug("retryInProgress event list ... " + retryInProgressEvents);
		logger.debug("failed event list ... " + failedEvents);
		logger.debug("retryFailed event list ... " + retryFailedEvents);

		// merging all the list and retrying one by one events form the list and
		// priority is list is set.
		List<EventDispatcherTracker> entireFailedList = mergeAllFailedEventList(newLongTimeEvents, failedEvents,
				retryFailedEvents, inProgressEvents, retryInProgressEvents);
		logger.debug("entireFailedList..." + entireFailedList);

		List<EventDispatcherTracker> filteredList = removeEventsNotInDataGrid(entireFailedList, exchange);
		logger.debug("filteredList..." + filteredList);

		// filtering the event list according to retry-policy.
		List<EventDispatcherTracker> policyFilteredEventFailedList = EventFrameworkRetryPolicyService
				.filterFailedListWithPoilcy(filteredList);
		logger.debug("policyFilteredEventFailedList..." + policyFilteredEventFailedList);

		retryFailedEventsOneByOne(policyFilteredEventFailedList, exchange);

	}

	private List<EventDispatcherTracker> removeEventsNotInDataGrid(List<EventDispatcherTracker> entireFailedList,
			final Exchange exchange) throws EventDispatcherTrackerException {
		if (!entireFailedList.isEmpty()) {
			logger.debug("remove events not indatagrid ... " + entireFailedList);
			for (int i = 0; i < entireFailedList.size(); i++) {
				EventDispatcherTracker eventDispatcherTracker = entireFailedList.get(i);
				String tenantId = eventDispatcherTracker.getTenantId();
				String siteId = eventDispatcherTracker.getSiteId();
				String requestId = eventDispatcherTracker.getRequestId();
				String eventStoreKey = eventDispatcherTracker.getEventStoreId();
				IMap<String, ArrayList<LeapEvent>> hcEventMap = getHazelCastMapValue(eventStoreKey);
				// if the HazelCastList of events is empty than mark
				// status as complete.
				boolean eventListStatus = hcEventMap.isEmpty();
				if (eventListStatus) {
					entireFailedList.remove(eventDispatcherTracker);
					eventDispatcherTrackerService.updateEventStatus(tenantId, siteId, requestId, eventStoreKey,
							EventTrackerTableConstants.STATUS_COMPLETE, exchange, false, null, false, false);
				}

				logger.debug("removing record not in Grid...!" + eventDispatcherTracker);
				boolean removedTrackRecord = eventDispatcherTrackerService.removeEventTrackRecord(tenantId, siteId,
						requestId, eventStoreKey, exchange);
				// Clean Hazelcast EventMap. We are done publishing all
				// events only by checking track record is deleted from
				// tracktable for specific request on status COMPLETE .
				if (removedTrackRecord)
					deleteHazelCastMapForRequest(eventStoreKey);
			}
		}
		return entireFailedList;
	}

	private void retryFailedEventsOneByOne(final List<EventDispatcherTracker> failedEvents, final Exchange exchange)
			throws EventDispatcherTrackerException {
		if (!failedEvents.isEmpty()) {
			logger.debug(
					"republish is done after updating status as RETRY_INPROCESS for particular failed event list ... "
							+ failedEvents);
			for (EventDispatcherTracker eventDispatcherTracker : failedEvents) {
				String tenantId = eventDispatcherTracker.getTenantId();
				String siteId = eventDispatcherTracker.getSiteId();
				String requestId = eventDispatcherTracker.getRequestId();
				String eventStoreKey = eventDispatcherTracker.getEventStoreId();
				String failureMsg = eventDispatcherTracker.getFailureReason();
				Integer retryCount = eventDispatcherTracker.getRetryCount();
				boolean isFailure = failureMsg != null;
				logger.info("retry attempt for events on requestId: " + requestId + " is " + retryCount);
				IMap<String, ArrayList<LeapEvent>> hcEventMap = getHazelCastMapValue(eventStoreKey);
				// if the HazelCastList of events is empty than mark
				// status as complete.
				boolean eventListStatus = hcEventMap.isEmpty();
				if (eventListStatus)
					eventDispatcherTrackerService.updateEventStatus(tenantId, siteId, requestId, eventStoreKey,
							EventTrackerTableConstants.STATUS_COMPLETE, exchange, false, null, false, false);
				else {
					// republish will be done for events with
					// NEW,IN_PROCESS,RETRY_INPROCESS(based on retry count) for
					// long time and retryAble exceptions.
					if (checkIsRetryable(failureMsg, isFailure)
							|| eventDispatcherTracker.getStatus()
									.equalsIgnoreCase(EventTrackerTableConstants.STATUS_NEW)
							|| eventDispatcherTracker.getStatus()
									.equalsIgnoreCase(EventTrackerTableConstants.STATUS_IN_PROCESS)
							|| eventDispatcherTracker.getStatus()
									.equalsIgnoreCase(EventTrackerTableConstants.STATUS_RETRY_IN_PROCESS)) {
						eventDispatcherTrackerService.updateEventStatus(tenantId, siteId, requestId, eventStoreKey,
								EventTrackerTableConstants.STATUS_RETRY_IN_PROCESS, exchange, isFailure, failureMsg,
								false, true);
						rePublishComponentEvent(hcEventMap, tenantId, siteId, requestId, eventStoreKey, exchange);
					}
				}
				logger.debug("removing track record after dispatching track status is COMPLETE...!");
				boolean removedTrackRecord = eventDispatcherTrackerService.removeEventTrackRecord(tenantId, siteId,
						requestId, eventStoreKey, exchange);
				// Clean Hazelcast EventList. We are done publishing all
				// events only by checking track record is deleted from
				// tracktable for specific request on status COMPLETE .
				if (removedTrackRecord)
					deleteHazelCastMapForRequest(eventStoreKey);
			}
		}

	}

	/**
	 * utility to check whether the eventlist is retryable or not.
	 * 
	 * @param failureMsg
	 * @param isFailure
	 * @return isRetryable
	 */
	private boolean checkIsRetryable(String failureMsg, boolean isFailure) {
		logger.debug("inside checkIsRetryable...for failureMsg: " + failureMsg);
		if (isFailure) {
			try {
				JSONObject failureJSON = new JSONObject(failureMsg);
				logger.debug(" isretriable " + Boolean.parseBoolean(
						failureJSON.get(EventTrackerTableConstants.IS_RETRYABLE).toString().toLowerCase().trim()));
				return Boolean.parseBoolean(
						failureJSON.get(EventTrackerTableConstants.IS_RETRYABLE).toString().toLowerCase().trim());
			} catch (Exception e) {
				logger.warn("Due to unable to check retry status retry will be not performed..." + e.getMessage());
				return false;
			}
		} else {
			logger.debug("is Failure " + isFailure);
			return isFailure;
		}
	}

	/**
	 * combining all failed event list and adding failed list in order for
	 * execution.
	 * 
	 * @param newLongTimeEvents
	 * @param failedEvents
	 * @param retryFailedEvents
	 * @param inProgressEvents
	 * @param retryInProgressEvents
	 * @return
	 */
	private List<EventDispatcherTracker> mergeAllFailedEventList(List<EventDispatcherTracker> newLongTimeEvents,
			List<EventDispatcherTracker> failedEvents, List<EventDispatcherTracker> retryFailedEvents,
			List<EventDispatcherTracker> inProgressEvents, List<EventDispatcherTracker> retryInProgressEvents) {
		List<EventDispatcherTracker> finalRetryEventList = new ArrayList<EventDispatcherTracker>();

		// adding failed events in the linked-set will define the priority of
		// execution.
		Set<List<EventDispatcherTracker>> failedLists = new LinkedHashSet<>();
		failedLists.add(newLongTimeEvents);
		failedLists.add(inProgressEvents);
		failedLists.add(failedEvents);
		failedLists.add(retryFailedEvents);
		failedLists.add(retryInProgressEvents);

		for (List<EventDispatcherTracker> eventList : failedLists) {
			if (eventList != null)
				finalRetryEventList.addAll(eventList);

		}
		return finalRetryEventList;
	}

	/**
	 * This method is used to publish events present in the list.(i.e, service
	 * and component events.)
	 * 
	 * @param hcEventList
	 *            : list of component and service event in hazelcast
	 * @throws EventDispatcherTrackerException
	 */
	public void rePublishComponentEvent(IMap<String, ArrayList<LeapEvent>> hcEventList, final String tenantId,
			final String siteId, final String requestId, final String eventStoreKey, Exchange camelExchange)
			throws EventDispatcherTrackerException {
		logger.debug("inside re_publishComponentEvent() in RetryFailedEventTask bean");
		if (hcEventList == null || hcEventList.isEmpty()) {
			return;
		}
		JSONObject failureJson = new JSONObject();

		boolean isFailure = false;

		ILeapEventService eventService = new LeapEventService();
		if ((ArrayList<LeapEvent>) hcEventList.get(requestId) != null) {
			for (LeapEvent leapevent : (ArrayList<LeapEvent>) hcEventList.get(requestId)) {
				try {
					eventService.publishEvent(leapevent);
					logger.debug("removing the event from the HazelCast list after successfullyDelivered event -- >"
							+ leapevent.toString());
					hcEventList.remove(requestId);
					// only for logging the remaining event list.
					logger.debug("fetching remaning event list -- >" + getHazelCastMapValue(eventStoreKey));
				} catch (InvalidEventException | EventFrameworkConfigurationException
						| LeapEventTransformationException insExp) {
					isFailure = true;
					String failureMsg = insExp.getMessage();
					EventTrackerUtil.setFailureJSONString(failureJson, insExp, failureMsg);
					logger.error("Failed to republish event for eventId : " + leapevent.getEventId() + "!", insExp);
					eventDispatcherTrackerService.updateEventStatus(tenantId, siteId, requestId, eventStoreKey,
							EventTrackerTableConstants.STATUS_RETRY_FAILED, camelExchange, isFailure,
							failureJson.toString(), true, false);

				} catch (MessageDispatchingException mDispatchingException) {
					// message dispatching exception can be retryable or
					// nonretryable.
					isFailure = true;
					String failureMsg = mDispatchingException.getMessage();
					EventTrackerUtil.setFailureJSONString(failureJson, mDispatchingException, failureMsg);
					logger.error("Failed to republish event for eventId : " + leapevent.getEventId() + "!",
							mDispatchingException);
					eventDispatcherTrackerService.updateEventStatus(tenantId, siteId, requestId, eventStoreKey,
							EventTrackerTableConstants.STATUS_RETRY_FAILED, camelExchange, isFailure,
							failureJson.toString(), true, false);

				}
			}
			if (!isFailure) {
				logger.debug("updating status to complete...!");
				eventDispatcherTrackerService.updateEventStatus(tenantId, siteId, requestId, eventStoreKey,
						EventTrackerTableConstants.STATUS_COMPLETE, camelExchange, isFailure, null, false, false);
			}
		}
	}

	/**
	 * utility to event list attached to specified eventStoreKey.
	 * 
	 * @param eventStoreKey
	 * @return null if list is empty.
	 */

	private IMap<String, ArrayList<LeapEvent>> getHazelCastMapValue(String eventStoreKey) {

		logger.debug("inside getHazelCastMapValue() in RetryFailedEventTask...");
		HazelcastInstance hazelcastInstance = DataGridService.getDataGridInstance().getHazelcastInstance();

		logger.debug("eventStoreKey in getHazelCastMapValue : " + eventStoreKey);
		IMap<String, ArrayList<LeapEvent>> eventMap = hazelcastInstance.getMap(eventStoreKey);
		logger.debug("eventList id in getHazelCastMapValue : " + eventMap);

		if (eventMap == null || eventMap.isEmpty() || eventMap.get(eventStoreKey) == null) {
			logger.debug("eventList Is Empty attached for eventStoreKey : " + eventStoreKey);
			return eventMap;
		}
		for (LeapEvent event : (ArrayList<LeapEvent>) eventMap.get(eventStoreKey)) {
			logger.debug("event information attached to eventStoreKey : " + eventStoreKey + " --> " + event.toString());
		}
		return eventMap;
	}

	/**
	 * Destroy Hazelcast List having events for the given route/camel exhange
	 * based on unique eventStoreKey generated in the baseImpl Route.<br>
	 * 
	 * @param exchange
	 *            : Exchange
	 */
	private void deleteHazelCastMapForRequest(String eventStoreKey) {
		logger.debug("inside deleteHazelCastMapForRequest() in RetryFailedEventTask... ");

		HazelcastInstance hazelcastInstance = DataGridService.getDataGridInstance().getHazelcastInstance();
		logger.debug("rquestId in deletehazelcastEventmap : " + eventStoreKey);
		IMap<String, ArrayList<LeapEvent>> eventMap = hazelcastInstance.getMap(eventStoreKey);
		logger.debug("event list in delete hazelcast Map : " + eventMap);
		if (eventMap != null)
			eventMap.destroy();
	}

}
